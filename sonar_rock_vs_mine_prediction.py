# -*- coding: utf-8 -*-
"""sonar-rock-vs-mine-Prediction

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LX0uQoTQRFQ0WmQzjBpeQZZv4yvHl9gw
"""

"""Sonar Rock vs Mine Prediction (Advanced Version)"""

# Importing Dependencies
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.decomposition import PCA
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt

"""### Data Collection and Preprocessing"""

# Load the dataset
sonar_data = pd.read_csv('/content/Copy of sonar data.csv')

# Check for missing values
print("Missing values:\n", sonar_data.isnull().sum())

# Encode labels
X = sonar_data.drop(columns='R')
Y = sonar_data['R']

label_encoder = LabelEncoder()
Y_encoded = label_encoder.fit_transform(Y)  # 'R' → 1, 'M' → 0

# Outlier Removal using Z-score
z_scores = np.abs((X - X.mean()) / X.std())
X_clean = X[(z_scores < 3).all(axis=1)]
Y_clean = Y_encoded[X_clean.index]

# Feature Scaling
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X_clean)

# Dimensionality Reduction using PCA
pca = PCA(n_components=30)
X_pca = pca.fit_transform(X_scaled)
print("Explained Variance (First 5):", pca.explained_variance_ratio_[:5])

"""### Train-Test Split"""

X_train, X_test, Y_train, Y_test = train_test_split(
    X_pca, Y_clean, test_size=0.1, stratify=Y_clean, random_state=42)

print("Training set shape:", X_train.shape)
print("Test set shape:", X_test.shape)

"""### Model Training → Gradient Boosting"""

model = GradientBoostingClassifier(random_state=42)
model.fit(X_train, Y_train)

"""### Model Evaluation"""

# Training Accuracy
train_pred = model.predict(X_train)
train_accuracy = accuracy_score(Y_train, train_pred)
print("Training Accuracy:", train_accuracy)

# Test Accuracy
test_pred = model.predict(X_test)
test_accuracy = accuracy_score(Y_test, test_pred)
print("Test Accuracy:", test_accuracy)

# Classification Report
print("\nClassification Report:\n", classification_report(Y_test, test_pred, target_names=label_encoder.classes_))

# Confusion Matrix
conf_matrix = confusion_matrix(Y_test, test_pred)
plt.figure(figsize=(6, 4))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Greens',
            xticklabels=label_encoder.classes_,
            yticklabels=label_encoder.classes_)
plt.title('Confusion Matrix - Gradient Boosting')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.tight_layout()
plt.show()

"""### Predictive System"""

# Example input (same as before)
input_data = (0.0307,0.0523,0.0653,0.0521,0.0611,0.0577,0.0665,0.0664,0.1460,0.2792,
              0.3877,0.4992,0.4981,0.4972,0.5607,0.7339,0.8230,0.9173,0.9975,0.9911,
              0.8240,0.6498,0.5980,0.4862,0.3150,0.1543,0.0989,0.0284,0.1008,0.2636,
              0.2694,0.2930,0.2925,0.3998,0.3660,0.3172,0.4609,0.4374,0.1820,0.3376,
              0.6202,0.4448,0.1863,0.1420,0.0589,0.0576,0.0672,0.0269,0.0245,0.0190,
              0.0063,0.0321,0.0189,0.0137,0.0277,0.0152,0.0052,0.0121,0.0124,0.0055)

# Convert to DataFrame with proper feature names (same as original dataset)
input_df = pd.DataFrame([input_data], columns=X.columns)

# Preprocess
input_scaled = scaler.transform(input_df)
input_pca = pca.transform(input_scaled)

# Predict
prediction = model.predict(input_pca)
predicted_label = label_encoder.inverse_transform(prediction)[0]

if predicted_label == 'R':
    print("\nThe object is a Rock.")
else:
    print("\n\nThe object is a Mine.")

